# botctl
CLI утилита для проведения соревнований между ботами в рамках курса CS253. Интеллектуальные системы

# Требования к боту
+ Последним аргументом командной строки принимает цвет (очередь хода), которым он играет: `0` или `1`
+ `stdin`(`cin`) принимает ходы соперника
+ `stderr`(`cerr`) пишет свой ход (один на строке)
+ `stdout`(`cout`) пишет всё остальное - логи, информацию для человека, состояние доски
+ `exit code`: победа-`0`, поражение-`3`, ничья-`4` (соответственно, должен понимать, когда игра окончилась)

# Поддержка ОС
Сейчас поддерживается только Windows, [поддержка Linux и Mac планируется](https://github.com/RobolabGs2/botctl/issues/1).

# Использование
```
Usage:
botctl [flags] "path/to/mybot1.exe [addition args]" "path/to/mybot2.exe [addition args]"
  -o1 string
    	Куда перенаправить stdout первого бота 
    	'-' = stdout, '+' - stderr, '<dirname>' - будет сохранено в папку, файл на раунд, пусто - игнорировать (default "+")
  -o2 string
    	Куда перенаправить stdout второго бота 
    	'-' = stdout, '+' - stderr, '<dirname>' - будет сохранено в папку, файл на раунд, пусто - игнорировать
  -r int
    	Количество раундов (default 1)
```
 
По окончанию всех раундов будет выведен суммарный счёт (1 балл за победу, 0.5 за ничью, 0 за поражение).  
При смене раунда цвета меняются.
```
Раунд    reversi_bot_v2.exe               reversi_bot_v3.exe
0        Поражение, ходил первым          Победа, ходил вторым
1        Поражение, ходил вторым          Победа, ходил первым
2        Победа, ходил первым             Поражение, ходил вторым
3        Поражение, ходил вторым          Победа, ходил первым
4        Поражение, ходил первым          Победа, ходил вторым
5        Победа, ходил вторым             Поражение, ходил первым
6        Поражение, ходил первым          Победа, ходил вторым
7        Ничья, ходил вторым              Ничья, ходил первым
8        Победа, ходил первым             Поражение, ходил вторым
9        Поражение, ходил вторым          Победа, ходил первым
Итого    3.5                              6.5
```

## Примеры запуска
### Проверяем, что бот корректно работает с системой
`botctl test mybot.exe` - после чего бот должен сыграть один раунд сам с собой, в логах будет виден процесс.
### Мой бот имеет дополнительные аргументы
Допустим, бот `mybot.exe` дополнительным параметром принимает флаг `-d` с глубиной, 
и я хочу сравнить бота с разной глубиной.
Тогда можно запускать `botctl` так (кавычки зависят от ОС, Windows `"`, в Linux `'`):
```bash
botctl "mybot.exe -d 8" "mybot.exe -d 6"
```
### Запуск нескольких раундов
Для этого есть флаг `-r`
```bash
botctl -r 11 "mybot.exe -d 8" "mybot.exe -d 6"
```
### Управление выводом `stdout` ботов
С помощью флагов `-o1` и `-o2` можно управлять перенаправлением `stdout` ботов:
 
|Значение флага|Результат|
|---|---|
|`-`|Логи данного бота будут выводиться в консоль в `stdout`|
|`+`|Логи данного бота будут выводиться в консоль в `stderr` (значение по умолчанию для `-o1`)|
|`""`|Игнорировать (значение по умолачнию для `-o2`|
|`path/to/directory`|Сохранение логов бота в файлы в указанной директории (при необходимости будет создана). На каждый раунд по файлу с названиями вида: `round_0_bot_1_botname.txt`|

Например, выяснилось, что иногда бот некорректно распознаёт ничью, и хотелось бы получить логи такого события.
Для такого можно запустить много раундов с сохранением логов в файлы
```
botctl -r 20 -o1 logsdir -o2 logsdir bot1.exe bot2.exe 
```
После чего в папке `logsdir` окажутся файлы с логами обоих ботов, которые можно спокойно рассмотреть позднее.

Если нам не важны логи ботов (мы точно уверенны в их корректности, и хотим видеть лишь, сколько раундов было отыграно на данный момент),
то можно выключить вывод в консоль логов первого бота

```
botctl -r 20 -o1 "" bot1.exe bot2.exe
``` 
# FAQ
## Мне нужен компилятор go?|Где я могу скачать бинарник?
Все версии доступны в [релизах](https://github.com/RobolabGs2/botctl/releases), там есть архивы с бинарником и ридмишкой. При просмотре репозитория в гитхабе с компьютера это будет видно справа от списка файлов, под `About`. 
## Как мне увидеть отдельно, что бот пишет в stderr?
По умолчанию `stdout` и `stderr` выводятся в консоль. 
При работе в консоли `stdout` и `stderr` можно перенаправлять по отдельности в файлы или в качестве `stdin` в другие команды.

`command > filename1.txt 2> filename2.txt` - `stdout` окажется в `filename1.txt`, а `stderr` в `filename2.txt`.

Соответственно, можно вызвать бота `bot.exe 0 2> cerr.txt` и по содержимому `cerr.txt` увидеть, что и как бот туда написал.
И, поскольку `stderr` не буферизируется, то файл будет обновляться по мере игры с ботом. 
## `проблемы с ботом 1: 'bot1: CreateFile 'bot1.exe': The system cannot find the file specified`
1. Проверьте путь к файлу
2. Если при запуске использовались кавычки, попробуйте заменить `'` на `"` и наоборот, или убрать их вообще (если нет дополнительных аргументов)
   + Для Windows:
        * `botctl 'bot1.exe -d 4' 'bot2.exe'` - не правильно 
        * `botctl "bot1.exe -d 4" bot2.exe` - правильно
## Всё запускается, но бот зависает в ожидании хода противника
1. Убедитесь, что бот правильно воспринимает аргумент с очередью хода: `bot1.exe 0` - бот должен ходить первым, `bot1.exe 1` бот должен ходить вторым
    Если проблема здесь, то она может возникнуть по следующим причинам:
      - Не учтено, что в `args[0]` будет лежать название запущенной программы, а аргументы начинаются с `args[1]`
      - Происходит проверка вида `args[1][0] == 0` - сравнение кода символа с числом, а не с кодом символа числа, правильнее будет хотя бы `args[1][0] == '0'` или `args[1][0]-'0' == 0`
2.  Проверьте места чтения из `cin` и записи в `cerr`
    Скорее всего после хода нет никакого разделителя
      ```c++
      string move;
      cin >> move;
      <...>
      cerr << move; // никаких пробелов и переносов строк - не понятно, где граница между ходами
      ```
    При чтении `cin` строки будет происходить чтение до какого-то невидимого символа. 
    Однако, если пробелов/переносов строк нет, то `cin` не закончит чтение строки.
    Поэтому лучше писать `cerr << x << " " << y << endl;` 
    Ну или читать посимвольно (но тогда и боты противников должны это делать, так что лучше добавлять `endl` после хода) 